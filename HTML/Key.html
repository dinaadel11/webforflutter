<html>
    <head>
        <meta charset="UTF-8" />
        <title>Learn Widgets</title>
        <meta name="description" content="Learn widgets" />
        <link rel="stylesheet" href="../css/section1.css">
    </head>
    <body>
        <div class="keywidget">
            <h3 >Key Points about Widgets</h3>
            <ol>
                <li style="font-weight: bold;">Everything is a widget:</li>
                <ul>
                    <li>Every component in your app, from text, buttons, images, to entire screens, is a widget.</li>
                    <li>Flutter apps are built by combining different types of widgets to create complex UIs.</li>
                </ul>
                <li style="font-weight: bold;">Widgets in Flutter are immutable:</li>
                <ul>
                    <li>A widget in Flutter describes a part of the UI, but it doesnâ€™t change over time. If the UI needs
                        to change, Flutter creates a new widget with the new state.</li>
                    <li>The state of a widget (if it has any) is managed separately through Stateful widgets and
                        Stateless widgets.</li>
                </ul>
                <li style="font-weight: bold;">Types of Widgets:</li>
                <ul>
                    <li>Stateless Widgets: These are immutable, meaning their properties can't change after they are
                        created. A typical example would be a text label or an icon.</li>
                    <li>Stateful Widgets: These can change their appearance based on user interaction or other factors.
                        They are capable of holding mutable state.</li>
                </ul>
                <li style="font-weight: bold;" >Widget Hierarchy:</li>
                <ul>
                    <li>Widgets can contain other widgets. This creates a widget tree. For example, a screen (Scaffold
                        widget) may contain an AppBar, a Drawer, and a Body, and the body itself can contain many nested
                        widgets like Column, Text, Container, etc.</li>
                </ul>
            </ol>

Widgets are the building blocks of Flutter applications. They are responsible for describing the UI of your app, from the simplest text element to complex layouts. Here are some key points to remember:
<ol>
<li>Everything is a Widget:

    Every element on the screen, whether it's a button, a text field, or an image, is represented by a widget.
    This widget-based approach allows for a consistent and flexible way to build user interfaces.</li>
<li>Widget Tree:

    Flutter apps are structured as a tree of widgets, where each widget can have child widgets.
    The root widget is typically MaterialApp or CupertinoApp, and it branches out into smaller widgets that make up the UI.</li>
<li>Stateless vs. Stateful Widgets:

    Stateless Widgets:
    Immutable and do not change over time.
    Used for UI elements that do not require internal state.
    Examples: Text, Icon, Image.
    Stateful Widgets:
    Mutable and can change their state over time.
    Used for UI elements that need to update dynamically, like counters, forms, or animations.
    Examples: Button, TextField, Slider.</li>
<li>Layout Widgets:

    Row: Arranges children horizontally.
    Column: Arranges children vertically.
    Stack: Overlays children on top of each other.
    Container: A versatile widget for layout, padding, margin, and decoration.</li>
<li>
    Material Design and Cupertino:

Flutter offers two design languages: Material Design (Google's design language) and Cupertino (Apple's design language).
Each design language has its own set of widgets to match the specific platform's look and feel.
</li>
<li>
    Custom Widgets:

You can create your own custom widgets to encapsulate complex UI components.
This promotes code reusability and maintainability.
</li>
<li>
    State Management:

Flutter provides various state management techniques to manage the state of your widgets.
Popular methods include:
setState for simple state changes.
Provider and Riverpod for more complex state management.
BLoC pattern for managing complex business logic and state.
By understanding these key points, you can effectively build beautiful and responsive user interfaces with Flutter.
</li>
</ol>
        </div>
    </body>
</html>